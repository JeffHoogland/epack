#!/usr/bin/env python
# encoding: utf-8
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

from __future__ import absolute_import, print_function

import os
import sys
import magic
try:
    from urllib.parse import unquote
except:
    from urllib import unquote

try:
    from efl import ecore
    from efl import elementary
    from efl.evas import EVAS_HINT_EXPAND, EVAS_HINT_FILL
    from efl.elementary.window import StandardWindow
    from efl.elementary.innerwindow import InnerWindow
    from efl.elementary.box import Box
    from efl.elementary.ctxpopup import Ctxpopup
    from efl.elementary.icon import Icon
    from efl.elementary.label import Label
    from efl.elementary.frame import Frame
    from efl.elementary.genlist import Genlist, GenlistItemClass
    from efl.elementary.button import Button
    from efl.elementary.table import Table
    from efl.elementary.check import Check
    from efl.elementary.fileselector_button import FileselectorButton
    from efl.elementary.fileselector import Fileselector
    from efl.elementary.popup import Popup
    from efl.elementary.progressbar import Progressbar
    from efl.elementary.separator import Separator
except ImportError:
    print("ImportError: Please install Python-EFL:\n ",
          "https://git.enlightenment.org/bindings/python/python-efl.git/")
    exit(1)


EXPAND_BOTH = EVAS_HINT_EXPAND, EVAS_HINT_EXPAND
EXPAND_HORIZ = EVAS_HINT_EXPAND, 0.0
FILL_BOTH = EVAS_HINT_FILL, EVAS_HINT_FILL
FILL_HORIZ = EVAS_HINT_FILL, 0.0

# the extracting application needs support to read from stdin.
# and bsdtar is great at all.
EXTRACT_MAP = {
    'application/gzip': 'bsdtar -xf -','application/x-gzip': 'bsdtar -xf -',
    'application/bzip2': 'bsdtar -xf -','application/x-bzip2': 'bsdtar -xf -',
    'application/bz2': 'bsdtar -xf -','application/x-bz2': 'bsdtar -xf -',
    'application/rar': 'bsdtar -xf -','application/x-rar': 'bsdtar -xf -',
    'application/gz': 'bsdtar -xf -','application/x-gz': 'gbsdtar -xf -',
    'application/tar': 'bsdtar -xf -','application/x-tar': 'bsdtar -xf -',
    'application/tbz2': 'bsdtar -xf -','application/x-tbz2': 'bsdtar -xf -',
    'application/tar.bz2': 'bsdtar -xf -','application/x-tar.bz2': 'bsdtar -xf -',
    'application/tar.gz': 'bsdtar -xf -','application/x-tar.gz': 'bsdtar -xf -',
    'application/tgz': 'bsdtar -xf -','application/x-tgz': 'bsdtar -xf -',
    'application/zip': 'bsdtar -xf -','application/x-zip': 'bsdtar -xf -',
    'application/Z': 'bsdtar -xf -','application/x-Z': 'bsdtar -xf -',
    'application/xz': 'bsdtar -xf -','application/x-xz': 'bsdtar -xf -',
    'application/iso9660-image': 'bsdtar -xf -','application/x-iso9660-image': 'bsdtar -xf -'
}

LIST_MAP = {
    'application/gzip': 'bsdtar -tf','application/x-gzip': 'bsdtar -tf',
    'application/bzip2': 'bsdtar -tf','application/x-bzip2': 'bsdtar -tf',
    'application/bz2': 'bsdtar -tf','application/x-bz2': 'bsdtar -tf',
    'application/rar': 'bsdtar -tf','application/x-rar': 'bsdtar -tf',
    'application/gz': 'bsdtar -tf','application/x-gz': 'gbsdtar -tf',
    'application/tar': 'bsdtar -tf','application/x-tar': 'bsdtar -tf',
    'application/tbz2': 'bsdtar -tf','application/x-tbz2': 'bsdtar -tf',
    'application/tar.gz': 'bsdtar -tf','application/x-tar.gz': 'bsdtar -tf',
    'application/tar.bz2': 'bsdtar -tf','application/x-tar.bz2': 'bsdtar -tf',
    'application/tgz': 'bsdtar -tf','application/x-tgz': 'bsdtar -tf',
    'application/zip': 'bsdtar -tf','application/x-zip': 'bsdtar -tf',
    'application/Z': 'bsdtar -tf','application/x-Z': 'bsdtar -tf',
    'application/xz': 'bsdtar -tf','application/x-xz': 'bsdtar -tf',
    'application/iso9660-image': 'bsdtar -tf -','application/x-iso9660-image': 'bsdtar -tf -'
}


def mime_type_query(fname):
    m = magic.open(magic.MAGIC_MIME_TYPE)
    m.load()
    return m.file(fname)


def gl_text_get(obj, part, item_data):
    return item_data

def gl_fold_icon_get(obj, part, item_data):
    return Icon(obj, standard='folder')

def gl_file_icon_get(obj, part, item_data):
    return Icon(obj, standard='file')


class MainWin(StandardWindow):
    def __init__(self, fname):
        self.fname = fname
        self.mime_type = mime_type_query(fname)
        self.dest_folder = os.path.dirname(fname)
        self.post_extract_action = 'close' # or 'fm' or 'term'

        # the window
        StandardWindow.__init__(self, 'epack.py', 'Epack')
        self.autodel_set(True)
        self.callback_delete_request_add(lambda o: elementary.exit())


        if not EXTRACT_MAP.get(self.mime_type):
            errlb = Label(self)
            errlb.text_set("Mimetype: "+self.mime_type+" is not supported")
            errwin = InnerWindow(self, content=errlb)
            errwin.show()
        else:
            # main vertical box
            vbox = Box(self, size_hint_weight=EXPAND_BOTH)
            self.resize_object_add(vbox)
            vbox.show()

            ### header horiz box (inside a padding frame)
            frame = Frame(self, style='pad_medium',
                          size_hint_weight=EXPAND_HORIZ,
                          size_hint_align=FILL_HORIZ)
            vbox.pack_end(frame)
            frame.show()
            
            hbox = Box(self, horizontal=True, size_hint_weight=EXPAND_HORIZ,
                       size_hint_align=FILL_HORIZ)
            frame.content = hbox
            hbox.show()

            # spinner
            self.spinner = Progressbar(hbox, style="wheel", pulse_mode=True)
            self.spinner.pulse(True)
            self.spinner.show()
            hbox.pack_end(self.spinner)

            # info label
            self.hlabel = Label(hbox, text="Reading archive, please wait...",
                                size_hint_weight=EXPAND_HORIZ,
                                size_hint_align=(0.0, 0.5))
            self.hlabel.show()
            hbox.pack_end(self.hlabel)

            # genlist with archive content
            self.file_itc = GenlistItemClass(item_style="one_icon",
                                             text_get_func=gl_text_get,
                                             content_get_func=gl_file_icon_get)
            self.fold_itc = GenlistItemClass(item_style="one_icon",
                                             text_get_func=gl_text_get,
                                             content_get_func=gl_fold_icon_get)
            self.file_list = Genlist(self, homogeneous=True,
                                     size_hint_weight=EXPAND_BOTH,
                                     size_hint_align=FILL_BOTH)
            vbox.pack_end(self.file_list)
            self.file_list.show()

            ### footer table (inside a padding frame)
            frame = Frame(self, style='pad_medium',
                          size_hint_weight=EXPAND_HORIZ,
                          size_hint_align=FILL_HORIZ)
            vbox.pack_end(frame)
            frame.show()
            
            table = Table(frame)
            frame.content = table
            table.show()

            # fsb
            icon = Icon(table, standard='folder')
            self.fsb = FileselectorButton(self, inwin_mode=False, content=icon,
                                    folder_only=True, text=self.dest_folder,
                                    size_hint_weight=EXPAND_HORIZ,
                                    size_hint_align=FILL_HORIZ)
            self.fsb.callback_file_chosen_add(self.chosen_folder_cb)
            table.pack(self.fsb, 0, 0, 3, 1)
            self.fsb.show()

            sep = Separator(table, horizontal=True,
                            size_hint_weight=EXPAND_HORIZ)
            table.pack(sep, 0, 1, 3, 1)
            sep.show()

            # extract button
            btn_box = Box(table, horizontal=True)
            table.pack(btn_box, 0, 2, 1, 2)
            btn_box.show()
            
            self.btn1 = Button(table, text='Extract', disabled=True)
            self.btn1.callback_clicked_add(self.extract_btn_cb)
            btn_box.pack_end(self.btn1)
            self.btn1.show()

            ic = Icon(table, standard='arrow_up', size_hint_min=(17,17))
            self.btn2 = Button(table, content=ic)
            self.btn2.callback_clicked_add(self.extract_opts_cb)
            btn_box.pack_end(self.btn2)
            self.btn2.show()

            sep = Separator(table, horizontal=False)
            table.pack(sep, 1, 2, 1, 2)
            sep.show()

            # delete archive checkbox
            self.del_chk = Check(table, text="Delete archive after extraction",
                                 size_hint_weight=EXPAND_HORIZ,
                                 size_hint_align=(0.0, 1.0))
            table.pack(self.del_chk, 2, 2, 1, 1)
            self.del_chk.show()

            # create archive folder
            self.create_folder_chk = Check(table, text="Create archive folder",
                                           size_hint_weight=EXPAND_HORIZ,
                                           size_hint_align=(0.0, 1.0))
            table.pack(self.create_folder_chk, 2, 3, 1, 1)
            self.create_folder_chk.show()

            # ask for the archive content list
            backend.list_content(self.fname, self.mime_type, self.list_done_cb)

        # show the window
        self.resize(300, 300)
        self.show()

    def extract_opts_cb(self, bt):
        ctx = Ctxpopup(self, hover_parent=self)
        ctx.item_append('Extract and open FileManager', None,
                        self.change_post_extract_action, 'fm')
        ctx.item_append('Extract and open in Terminal', None,
                        self.change_post_extract_action, 'term')
        ctx.item_append('Extract and close', None,
                        self.change_post_extract_action, 'close')
        x, y, w, h = bt.geometry
        ctx.pos = (x + w / 2, y)
        ctx.show()

    def change_post_extract_action(self, ctx, item, action):
        self.post_extract_action = action
        if action == 'fm':
            self.btn1.text = 'Extract and open FileManager'
        elif action == 'term':
            self.btn1.text = 'Extract and open in Terminal'
        elif action == 'close':
            self.btn1.text = 'Extract'
        ctx.delete()
        
        
    def update_header(self):
        self.hlabel.text = "<b>Archive:</b> %s" % (os.path.basename(self.fname))

    def show_error_msg(self, msg):
        pop = Popup(self, text=msg)
        pop.part_text_set('title,text', 'Error')

        btn = Button(self, text='Continue')
        btn.callback_clicked_add(lambda b: pop.delete())
        pop.part_content_set('button1', btn)

        btn = Button(self, text='Exit')
        btn.callback_clicked_add(lambda b: elementary.exit())
        pop.part_content_set('button2', btn)

        pop.show()

    def chosen_folder_cb(self, fsb, folder):
        if folder:
            self.dest_folder = folder
            fsb.text = folder

    def extract_btn_cb(self, btn):
        if self.create_folder_chk.state == True:
            folder = os.path.basename(self.fname)
            self.dest_folder = os.path.join(self.dest_folder, folder)
            os.mkdir(self.dest_folder)

        pp = Popup(self)
        pp.part_text_set('title,text', 'Extracting files, please wait...')
        pp.show()

        vbox = Box(self)
        pp.part_content_set('default', vbox)
        vbox.show()

        lb = Label(self, ellipsis=True, size_hint_weight=EXPAND_HORIZ,
                   size_hint_align=FILL_HORIZ)
        vbox.pack_end(lb)
        lb.show()

        pb = Progressbar(pp, size_hint_weight=EXPAND_HORIZ,
                         size_hint_align=FILL_HORIZ)
        vbox.pack_end(pb)
        pb.show()

        bt = Button(pp, text='Cancel', disabled=True)
        pp.part_content_set('button1', bt)

        self.prog_pbar = pb
        self.prog_label = lb
        self.popup = pp

        backend.extract(self.fname, self.mime_type, self.dest_folder,
                        self.extract_progress_cb,
                        self.extract_done_cb)

    def list_done_cb(self, file_list):
        for fname in file_list:
            if fname.endswith('/'):
                self.file_list.item_append(self.fold_itc, fname)
            else:
                self.file_list.item_append(self.file_itc, fname)

        self.spinner.pulse(False)
        self.spinner.delete()
        self.btn1.disabled = False
        self.update_header()

    def extract_progress_cb(self, progress, fname):
        self.prog_pbar.value = progress
        self.prog_label.text = fname

    def extract_done_cb(self, result):
        if result == 'success':
            if self.del_chk.state == True:
                os.remove(self.fname)
            elementary.exit()
        else:
            self.show_error_msg(result)
            self.popup.delete()


class FileChooserWin(StandardWindow):
    def __init__(self):
        StandardWindow.__init__(self, 'epack.py', 'Choose an archive')
        self.autodel_set(True)
        self.callback_delete_request_add(lambda o: elementary.exit())

        fs = Fileselector(self, expandable=False,
                          path=os.path.expanduser('~'),
                          size_hint_weight=EXPAND_BOTH,
                          size_hint_align=FILL_BOTH)
        fs.callback_done_add(self.done_cb)
        fs.mime_types_filter_append(list(EXTRACT_MAP.keys()), 'Archive files')
        fs.mime_types_filter_append(['*'], 'All files')
        fs.show()

        self.resize_object_add(fs)
        self.resize(300, 400)
        self.show()

    def done_cb(self, fs, path):
        if path is None:
            elementary.exit()
            return

        if not os.path.isdir(path):
            MainWin(path)
            self.delete()


class ShellBackend(object):
    """ This backend use pv + bsdtar to extract archives
        Use ecore.Exe to don't block the UI.
    """
    name = "pv | bsdtar in an ecore.Exe"

    def __init__(self):
        # TODO backend requirement checks here
        pass

    def list_content(self, archive_file, mime_type, done_cb):
        self._contents = list()
        cmd = '%s "%s"' % (LIST_MAP.get(mime_type), archive_file)
        exe = ecore.Exe(cmd, ecore.ECORE_EXE_PIPE_READ |
                             ecore.ECORE_EXE_PIPE_READ_LINE_BUFFERED)
        exe.on_data_event_add(self._list_stdout)
        exe.on_del_event_add(self._list_done, done_cb)

    def extract(self, archive_file, mime_type, destination, progress_cb):
        os.chdir(destination)
        cmd = 'pv -n "%s" | %s ' % (archive_file, EXTRACT_MAP.get(mime_type))
        exe = ecore.Exe(cmd, ecore.ECORE_EXE_PIPE_ERROR |
                             ecore.ECORE_EXE_PIPE_ERROR_LINE_BUFFERED)
        exe.on_error_event_add(self._extract_stderr, progress_cb)
        exe.on_del_event_add(self._extract_done, progress_cb)

    def _list_stdout(self, command, event):
        self._contents.extend(event.lines)

    def _list_done(self, command, event, done_cb):
        done_cb(self._contents)

    def _extract_stderr(self, command, event, progress_cb):
        progress = float(event.lines[0])
        progress_cb(progress / 100)

    def _extract_done(self, command, event, progress_cb):
        progress_cb('done')


class LibarchiveBackend(object):
    """ This backend use the python libarchive wrapper included in epack
        The wrappers are a plain copy from:
        https://pypi.python.org/pypi/libarchive-c/1.0

        Use threading to don't block the UI.
    """
    name = "Libarchive in a thread"

    def __init__(self):
        import epack.libarchive
        import threading
        try:    from queue import Queue # py3
        except: from Queue import Queue # py2

        self.libarchive = epack.libarchive
        self.Thread = threading.Thread
        self._queue = Queue()
        self._total_size = 0

    def list_content(self, archive_file, mime_type, done_cb):
        ecore.Timer(0.1, self._check_list_queue, done_cb)
        self.Thread(target=self._list_in_a_thread,
                    args=(archive_file,)).start()

    def extract(self, archive_file, mime_type, destination, progress_cb, done_cb):
        ecore.Timer(0.1, self._check_extract_queue, progress_cb, done_cb)
        self.Thread(target=self._extract_in_a_thread,
                    args=(archive_file, destination)).start()

    def _list_in_a_thread(self, archive_file):
        L = list()
        self._total_size = 0
        with self.libarchive.file_reader(archive_file) as archive:
            for entry in archive:
                L.append(entry.pathname)
                self._total_size += entry.size
        self._queue.put(L)

    def _extract_in_a_thread(self, archive_file, destination):
        written = 0
        try:
            with self.libarchive.file_reader(archive_file) as archive:
                for entry in archive:
                    # print(entry.pathname, entry.size, oct(entry.perm), entry.mtime)
                    path = os.path.join(destination, entry.pathname)

                    # create a folder
                    if entry.isdir:
                        if not os.path.exists(path):
                            os.mkdir(path)

                    # or write a file to disk
                    else: # TODO test other special types
                        with open(path, 'wb') as f:
                            for block in entry.get_blocks():
                                f.write(block)
                                written += len(block)
                                perc = float(written) / self._total_size
                                self._queue.put((perc, entry.pathname))

                    # apply correct time and permission
                    os.utime(path, (-1, entry.mtime))
                    os.chmod(path, entry.perm)
        except Exception as e:
            self._queue.put(('error', str(e)))
        else:
            self._queue.put(('done', 'success'))

    def _check_list_queue(self, done_cb):
        if self._queue.empty():
            return ecore.ECORE_CALLBACK_RENEW

        done_cb(self._queue.get())
        return ecore.ECORE_CALLBACK_CANCEL

    def _check_extract_queue(self, progress_cb, done_cb):
        # is an item available in the queue ?
        if self._queue.empty():
            return ecore.ECORE_CALLBACK_RENEW

        # get the last item in the queue
        while not self._queue.empty():
            item1, item2 = self._queue.get()

        # call the progress callback
        if isinstance(item1, float):
            progress_cb(item1, item2)
            return ecore.ECORE_CALLBACK_RENEW

        # call the done callback
        done_cb(item2)
        return ecore.ECORE_CALLBACK_CANCEL


def load_backend():
    for backend in LibarchiveBackend, ShellBackend:
        try:
            instance = backend()
            break
        except Exception as e:
            print(e)
            instance = None

    if instance is None:
        print('Cannot find a working backend')
        exit(1)

    print('Using backend: "%s"' % backend.name)
    return instance
    

if __name__ == "__main__":

    backend = load_backend()

    elementary.init()
    elementary.need.need_efreet()

    if len(sys.argv) < 2:
        FileChooserWin()
    else:
        fname = sys.argv[1]
        if fname.startswith('file://'):
            fname = unquote(fname)[7:]
        else:
            fname = os.path.abspath(fname)
        MainWin(fname)

    elementary.run()
    elementary.shutdown()
